<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Flappy Bird</title>
    <!-- v10-fix -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #4ec0ca;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 480px;
            aspect-ratio: 3/4;
            max-height: 100vh;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #sound-toggle {
            position: absolute;
            top: 8px; right: 8px;
            z-index: 25;
            background: rgba(255,255,255,0.6);
            border: 2px solid #543;
            color: #543;
            font-size: 14px;
            width: 30px; height: 30px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
        }
        #sound-toggle.muted { opacity: 0.35; }
        @media (max-width: 480px) { #game-container { max-width: 100vw; } }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game"></canvas>
        <button id="sound-toggle" title="Toggle Sound">ðŸ”Š</button>
    </div>

    <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const GW = 288, GH = 512;
    canvas.width = GW;
    canvas.height = GH;

    // ============ AUDIO ============
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null, masterGain = null, soundEnabled = true;
    function initAudio() {
        if (audioCtx) return;
        audioCtx = new AudioCtx();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.3;
        masterGain.connect(audioCtx.destination);
    }
    function playTone(freq, dur, type, vol) {
        if (!audioCtx || !soundEnabled) return;
        const t = audioCtx.currentTime;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type || 'sine'; o.frequency.value = freq;
        g.gain.setValueAtTime(vol || 0.12, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + dur);
        o.connect(g); g.connect(masterGain);
        o.start(t); o.stop(t + dur);
    }
    function sfxFlap() { playTone(600, 0.07, 'triangle', 0.15); }
    function sfxScore() { playTone(800, 0.06, 'sine', 0.12); setTimeout(() => playTone(1200, 0.1, 'sine', 0.1), 60); }
    function sfxHit() { playTone(180, 0.12, 'square', 0.14); }
    function sfxDie() { playTone(250, 0.12, 'sawtooth', 0.08); setTimeout(() => playTone(150, 0.2, 'sawtooth', 0.06), 100); }
    function sfxSwoosh() { playTone(400, 0.1, 'sine', 0.06); playTone(500, 0.08, 'triangle', 0.04); }

    // ============ CONSTANTS ============
    // Difficulty presets: [gravity, flap, pipeSpeed, pipeGap, pipeDist, maxFall, hitboxShrinkX, hitboxShrinkY]
    const LEVELS = {
        beginner: { name: 'BEGINNER', color: '#4caf50', gravity: 0.08, flap: -2.5, speed: 1.0, gap: 200, dist: 240, maxFall: 2.5, hbx: 14, hby: 12, firstPipe: 350 },
        easy:     { name: 'EASY',     color: '#8bc34a', gravity: 0.12, flap: -3.0, speed: 1.2, gap: 180, dist: 220, maxFall: 3.0, hbx: 12, hby: 10, firstPipe: 280 },
        medium:   { name: 'MEDIUM',   color: '#ff9800', gravity: 0.22, flap: -4.5, speed: 1.8, gap: 140, dist: 190, maxFall: 5.0, hbx: 6,  hby: 4,  firstPipe: 200 },
        hard:     { name: 'HARD',     color: '#f44336', gravity: 0.32, flap: -5.8, speed: 2.2, gap: 115, dist: 170, maxFall: 7.0, hbx: 3,  hby: 2,  firstPipe: 140 },
        insane:   { name: 'INSANE',   color: '#9c27b0', gravity: 0.40, flap: -6.5, speed: 2.8, gap: 100, dist: 155, maxFall: 9.0, hbx: 0,  hby: 0,  firstPipe: 100 },
    };
    const LEVEL_KEYS = ['beginner', 'easy', 'medium', 'hard', 'insane'];
    let currentLevel = 'easy';
    let diff = LEVELS[currentLevel];

    const PIPE_W = 52;
    const GROUND_H = 112;
    const GROUND_Y = GH - GROUND_H;
    const BIRD_W = 34, BIRD_H = 24;

    // ============ STATE ============
    function getBest() { return parseInt(localStorage.getItem('fb_best_' + currentLevel) || '0'); }
    function setBest(v) { localStorage.setItem('fb_best_' + currentLevel, v); }
    let best = getBest();
    let bird = { x: 68, y: 180, vy: 0, rot: 0, wing: 0, frame: 0 };
    let pipes = [], score = 0, state = 'title', fc = 0, groundX = 0;
    let flashAlpha = 0, dieY = 0, showScore = false;
    let readyTimer = 0;
    let clouds = [], buildings = [];

    function initWorld() {
        clouds = [];
        for (let i = 0; i < 5; i++) clouds.push({ x: Math.random() * GW * 1.2, y: 30 + Math.random() * 100, s: 0.6 + Math.random() * 0.6 });
        buildings = [];
        let bx = 0;
        while (bx < GW + 60) { const w = 14 + Math.random() * 22; buildings.push({ x: bx, w, h: 20 + Math.random() * 55 }); bx += w + Math.random() * 4; }
    }

    // ============ DRAW HELPERS ============
    function drawRoundRect(x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }

    // ============ BACKGROUND ============
    function drawBg() {
        // Sky gradient
        const g = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
        g.addColorStop(0, '#4ec0ca');
        g.addColorStop(0.6, '#62d0d0');
        g.addColorStop(1, '#b0e8b0');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, GW, GROUND_Y);

        // Clouds
        clouds.forEach(c => {
            drawCloud(c.x, c.y, c.s);
        });

        // City far (light)
        ctx.fillStyle = 'rgba(180,210,160,0.7)';
        buildings.forEach(b => {
            const ox = ((b.x - groundX * 0.1) % (GW + 60) + GW + 60) % (GW + 60) - 30;
            ctx.fillRect(ox, GROUND_Y - b.h * 0.5, b.w, b.h * 0.5);
        });
        // City near
        ctx.fillStyle = 'rgba(140,190,130,0.8)';
        buildings.forEach(b => {
            const ox = ((b.x + 40 - groundX * 0.2) % (GW + 60) + GW + 60) % (GW + 60) - 30;
            ctx.fillRect(ox, GROUND_Y - b.h * 0.35, b.w * 0.9, b.h * 0.35);
        });
    }

    function drawCloud(x, y, scale) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI * 2);
        ctx.arc(20, -5, 16, 0, Math.PI * 2);
        ctx.arc(-18, 2, 14, 0, Math.PI * 2);
        ctx.arc(10, 5, 14, 0, Math.PI * 2);
        ctx.arc(-8, -8, 13, 0, Math.PI * 2);
        ctx.arc(30, 3, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // ============ PIPES ============
    function drawPipe(px, topH) {
        const capH = 26, capOv = 3;
        const bodyX = px, bodyW = PIPE_W;
        const capX = px - capOv, capW = PIPE_W + capOv * 2;
        const botY = topH + diff.gap;
        const botH = GROUND_Y - botY;

        // --- TOP PIPE ---
        // Body
        drawPipeBody(bodyX, 0, bodyW, topH - capH);
        // Cap
        drawPipeCap(capX, topH - capH, capW, capH);

        // --- BOTTOM PIPE ---
        // Cap
        drawPipeCap(capX, botY, capW, capH);
        // Body
        drawPipeBody(bodyX, botY + capH, bodyW, botH - capH);
    }

    function drawPipeBody(x, y, w, h) {
        if (h <= 0) return;
        // Main green
        ctx.fillStyle = '#73bf2e';
        ctx.fillRect(x, y, w, h);
        // Left highlight
        ctx.fillStyle = '#8fd644';
        ctx.fillRect(x + 2, y, 6, h);
        // Second highlight
        ctx.fillStyle = '#a0e855';
        ctx.fillRect(x + 8, y, 3, h);
        // Right shadow
        ctx.fillStyle = '#568f1e';
        ctx.fillRect(x + w - 7, y, 7, h);
        // Dark edge
        ctx.fillStyle = '#3a6a10';
        ctx.fillRect(x + w - 2, y, 2, h);
        // Left dark edge
        ctx.fillStyle = '#4a7a18';
        ctx.fillRect(x, y, 2, h);
        // Outline
        ctx.strokeStyle = '#2a5a10';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(x, y, w, h);
    }

    function drawPipeCap(x, y, w, h) {
        // Main
        ctx.fillStyle = '#73bf2e';
        drawRoundRect(x, y, w, h, 3);
        ctx.fill();
        // Left highlight
        ctx.fillStyle = '#8fd644';
        ctx.fillRect(x + 3, y + 2, 6, h - 4);
        ctx.fillStyle = '#a0e855';
        ctx.fillRect(x + 9, y + 2, 3, h - 4);
        // Right shadow
        ctx.fillStyle = '#568f1e';
        ctx.fillRect(x + w - 8, y + 2, 6, h - 4);
        ctx.fillStyle = '#3a6a10';
        ctx.fillRect(x + w - 3, y + 2, 2, h - 4);
        // Outline
        ctx.strokeStyle = '#2a5a10';
        ctx.lineWidth = 1.5;
        drawRoundRect(x, y, w, h, 3);
        ctx.stroke();
        // Top/bottom shine line
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillRect(x + 4, y + 2, w - 8, 2);
    }

    // ============ GROUND ============
    function drawGround() {
        // Grass
        ctx.fillStyle = '#6abf2e';
        ctx.fillRect(0, GROUND_Y, GW, 6);
        // Ground body
        ctx.fillStyle = '#ded895';
        ctx.fillRect(0, GROUND_Y + 6, GW, GROUND_H - 6);
        // Ground stripes
        ctx.fillStyle = '#c8b864';
        const sw = 24;
        for (let gx = -(groundX % (sw * 2)); gx < GW + sw; gx += sw * 2) {
            ctx.fillRect(gx, GROUND_Y + 12, sw, 4);
        }
        for (let gx = -(groundX % (sw * 2)) + sw; gx < GW + sw; gx += sw * 2) {
            ctx.fillRect(gx, GROUND_Y + 22, sw, 4);
        }
        // Top dark line
        ctx.fillStyle = '#543';
        ctx.fillRect(0, GROUND_Y, GW, 2);
    }

    // ============ BIRD ============
    function drawBird() {
        const { x, y, rot } = bird;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rot);

        const bw = BIRD_W, bh = BIRD_H;

        // Tail feathers
        ctx.fillStyle = '#ddd';
        ctx.beginPath();
        ctx.moveTo(-bw/2 + 3, -3);
        ctx.lineTo(-bw/2 - 8, -7);
        ctx.lineTo(-bw/2 - 7, 0);
        ctx.lineTo(-bw/2 - 8, 7);
        ctx.lineTo(-bw/2 + 3, 4);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Body shadow
        ctx.fillStyle = '#c87000';
        ctx.beginPath();
        ctx.ellipse(0, 2, bw/2, bh/2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Main body â€” orange like original
        const bg = ctx.createRadialGradient(-4, -3, 1, 0, 0, bw/2);
        bg.addColorStop(0, '#ffc840');
        bg.addColorStop(0.4, '#f0a020');
        bg.addColorStop(0.8, '#e08010');
        bg.addColorStop(1, '#d07008');
        ctx.fillStyle = bg;
        ctx.beginPath();
        ctx.ellipse(0, 0, bw/2, bh/2, 0, 0, Math.PI * 2);
        ctx.fill();
        // Outline
        ctx.strokeStyle = '#805000';
        ctx.lineWidth = 1.8;
        ctx.stroke();

        // Belly patch (lighter)
        ctx.fillStyle = '#fce0a0';
        ctx.beginPath();
        ctx.ellipse(4, 4, bw/2 - 8, bh/2 - 5, 0.1, 0, Math.PI * 2);
        ctx.fill();

        // Wing
        const wy = Math.sin(bird.wing) * 5;
        ctx.fillStyle = '#eee';
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.ellipse(-3, wy + 1, 12, 7, -0.1, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Wing inner detail
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.ellipse(-2, wy, 7, 4, -0.1, 0, Math.PI * 2);
        ctx.fill();

        // Eye white â€” big round like original
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(10, -4, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Pupil â€” big and centered-right
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(13, -4, 4, 0, Math.PI * 2);
        ctx.fill();

        // Eye highlight
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(14.5, -6, 1.8, 0, Math.PI * 2);
        ctx.fill();

        // Beak â€” bright orange/red, two parts
        // Top beak
        ctx.fillStyle = '#f04030';
        ctx.beginPath();
        ctx.moveTo(14, -2);
        ctx.lineTo(26, 1);
        ctx.lineTo(14, 3);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#901808';
        ctx.lineWidth = 0.8;
        ctx.stroke();
        // Bottom beak (slightly lower, darker)
        ctx.fillStyle = '#d03020';
        ctx.beginPath();
        ctx.moveTo(14, 3);
        ctx.lineTo(24, 3);
        ctx.lineTo(14, 7);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#901808';
        ctx.stroke();

        ctx.restore();
    }

    // ============ UI ============
    function drawScore() {
        if (!showScore) return;
        const s = String(score);
        ctx.save();
        ctx.font = '28px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#543';
        ctx.fillText(s, GW/2 + 2, 52);
        ctx.fillStyle = '#fff';
        ctx.fillText(s, GW/2, 50);

        // Level badge top-left
        if (state === 'play') {
            ctx.font = '6px "Press Start 2P"';
            ctx.textAlign = 'left';
            ctx.fillStyle = diff.color;
            ctx.fillText(diff.name, 8, 18);
        }
        ctx.restore();
    }

    function drawGetReady() {
        ctx.save();
        ctx.textAlign = 'center';

        // "GET READY" text
        ctx.font = '18px "Press Start 2P"';
        ctx.fillStyle = '#543';
        ctx.fillText('GET READY', GW/2 + 2, 152);
        ctx.fillStyle = '#fff';
        ctx.fillText('GET READY', GW/2, 150);

        // Tap hand icon
        const hx = GW/2, hy = 280;
        // Hand circle
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.beginPath();
        ctx.arc(hx, hy, 22, 0, Math.PI * 2);
        ctx.fill();
        // Hand
        ctx.fillStyle = '#ded895';
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 1.5;
        // Palm
        ctx.beginPath();
        ctx.arc(hx, hy, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Finger
        ctx.fillStyle = '#ded895';
        ctx.beginPath();
        ctx.moveTo(hx - 4, hy - 10);
        ctx.lineTo(hx + 4, hy - 10);
        ctx.lineTo(hx + 3, hy - 26);
        ctx.lineTo(hx - 3, hy - 26);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        // Finger tip round
        ctx.beginPath();
        ctx.arc(hx, hy - 26, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Tap lines
        const tapAnim = Math.sin(fc * 0.1) * 3;
        ctx.strokeStyle = 'rgba(84,51,0,0.4)';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 3; i++) {
            const a = -Math.PI/2 + (i - 1) * 0.5;
            const r1 = 28 + tapAnim;
            const r2 = 36 + tapAnim;
            ctx.beginPath();
            ctx.moveTo(hx + Math.cos(a) * r1, hy + Math.sin(a) * r1 - 10);
            ctx.lineTo(hx + Math.cos(a) * r2, hy + Math.sin(a) * r2 - 10);
            ctx.stroke();
        }

        ctx.restore();
    }

    function drawGameOver() {
        ctx.save();
        ctx.textAlign = 'center';

        // "GAME OVER" text
        ctx.font = '18px "Press Start 2P"';
        ctx.fillStyle = '#543';
        ctx.fillText('GAME OVER', GW/2 + 2, 92);
        ctx.fillStyle = '#fff';
        ctx.fillText('GAME OVER', GW/2, 90);

        // Level badge
        ctx.font = '7px "Press Start 2P"';
        ctx.fillStyle = diff.color;
        ctx.fillText(diff.name, GW/2, 106);

        // Score panel
        const px = GW/2 - 80, py = 120, pw = 160, ph = 90;
        // Panel shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        drawRoundRect(px + 3, py + 3, pw, ph, 6);
        ctx.fill();
        // Panel bg
        ctx.fillStyle = '#ded895';
        drawRoundRect(px, py, pw, ph, 6);
        ctx.fill();
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 2.5;
        drawRoundRect(px, py, pw, ph, 6);
        ctx.stroke();
        // Inner border
        ctx.strokeStyle = 'rgba(84,51,0,0.2)';
        ctx.lineWidth = 1;
        drawRoundRect(px + 5, py + 5, pw - 10, ph - 10, 4);
        ctx.stroke();

        // Medal
        const mx = px + 24, my = py + ph/2;
        if (score >= 40) drawMedal(mx, my, '#ffd700', '#fff5a0'); // gold
        else if (score >= 20) drawMedal(mx, my, '#c0c0c0', '#e8e8e8'); // silver
        else if (score >= 10) drawMedal(mx, my, '#cd7f32', '#e0a050'); // bronze

        // Score
        ctx.textAlign = 'right';
        ctx.font = '12px "Press Start 2P"';
        ctx.fillStyle = '#543';
        ctx.fillText('SCORE', px + pw - 14, py + 28);
        ctx.fillStyle = '#fff';
        ctx.font = '14px "Press Start 2P"';
        ctx.fillText(String(score), px + pw - 14, py + 46);

        // Best
        ctx.font = '12px "Press Start 2P"';
        ctx.fillStyle = '#543';
        ctx.fillText('BEST', px + pw - 14, py + 62);
        ctx.fillStyle = '#fff';
        ctx.font = '14px "Press Start 2P"';
        ctx.fillText(String(best), px + pw - 14, py + 80);

        // NEW badge
        if (score > 0 && score >= best) {
            ctx.save();
            ctx.translate(px + pw - 50, py + 52);
            ctx.rotate(-0.1);
            ctx.fillStyle = '#f85030';
            drawRoundRect(-14, -7, 28, 13, 2);
            ctx.fill();
            ctx.font = '6px "Press Start 2P"';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText('NEW', 0, 3);
            ctx.restore();
        }

        // Play button
        const bx = GW/2 - 40, by = py + ph + 16, bw = 80, bh = 32;
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        drawRoundRect(bx + 2, by + 2, bw, bh, 4);
        ctx.fill();
        ctx.fillStyle = '#e08020';
        drawRoundRect(bx, by, bw, bh, 4);
        ctx.fill();
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 2;
        drawRoundRect(bx, by, bw, bh, 4);
        ctx.stroke();
        ctx.textAlign = 'center';
        ctx.font = '11px "Press Start 2P"';
        ctx.fillStyle = '#fff';
        ctx.fillText('PLAY', GW/2, by + 21);

        ctx.restore();
    }

    function drawMedal(cx, cy, c1, c2) {
        // Medal circle
        const g = ctx.createRadialGradient(cx - 3, cy - 3, 1, cx, cy, 16);
        g.addColorStop(0, c2);
        g.addColorStop(1, c1);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(cx, cy, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        // Star
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        drawStar(cx, cy, 5, 10, 5);
        ctx.fill();
    }

    function drawStar(cx, cy, spikes, outerR, innerR) {
        let rot = Math.PI / 2 * 3, step = Math.PI / spikes;
        ctx.beginPath();
        ctx.moveTo(cx, cy - outerR);
        for (let i = 0; i < spikes; i++) {
            ctx.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
            rot += step;
            ctx.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
            rot += step;
        }
        ctx.closePath();
    }

    function drawStyledText(text, x, y, size, fillColor, strokeColor, strokeW, tilt) {
        ctx.save();
        ctx.translate(x, y);
        if (tilt) ctx.rotate(tilt);
        ctx.font = `900 ${size}px "Press Start 2P"`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // Thick outline
        ctx.lineWidth = strokeW || 4;
        ctx.strokeStyle = strokeColor || '#543';
        ctx.lineJoin = 'round';
        ctx.miterLimit = 2;
        ctx.strokeText(text, 0, 0);
        // Fill
        ctx.fillStyle = fillColor || '#fff';
        ctx.fillText(text, 0, 0);
        ctx.restore();
    }

    let selectedIdx = 1; // default: easy

    function drawTitle() {
        ctx.save();

        // Title
        drawStyledText('Flappy', GW/2, 80, 26, '#fff', '#543', 5, -0.05);
        drawStyledText('Bird', GW/2 + 10, 112, 26, '#fff', '#543', 5, 0.03);

        // Difficulty selector
        const sy = 195, rowH = 30;
        ctx.textAlign = 'center';
        ctx.font = '8px "Press Start 2P"';
        ctx.fillStyle = '#543';
        ctx.fillText('SELECT LEVEL', GW/2, sy - 18);

        LEVEL_KEYS.forEach((key, i) => {
            const lv = LEVELS[key];
            const y = sy + i * rowH;
            const selected = i === selectedIdx;

            // Button bg
            if (selected) {
                // Selected highlight
                drawRoundRect(GW/2 - 65, y - 10, 130, 24, 4);
                ctx.fillStyle = lv.color;
                ctx.fill();
                ctx.strokeStyle = '#543';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Arrow indicators
                ctx.fillStyle = '#543';
                ctx.font = '10px "Press Start 2P"';
                ctx.fillText('â–º', GW/2 - 78, y + 5);
                ctx.fillText('â—„', GW/2 + 78, y + 5);
            } else {
                drawRoundRect(GW/2 - 60, y - 8, 120, 20, 3);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(84,51,0,0.2)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Level name
            ctx.font = selected ? '9px "Press Start 2P"' : '7px "Press Start 2P"';
            ctx.fillStyle = selected ? '#fff' : '#765';
            if (selected) { ctx.fillStyle = '#fff'; ctx.fillText(lv.name, GW/2 + 1, y + 5); }
            ctx.fillStyle = selected ? '#fff' : '#765';
            ctx.fillText(lv.name, GW/2, y + 4);
        });

        // Best score for selected level
        const selBest = parseInt(localStorage.getItem('fb_best_' + LEVEL_KEYS[selectedIdx]) || '0');
        if (selBest > 0) {
            ctx.font = '7px "Press Start 2P"';
            ctx.fillStyle = '#876';
            ctx.fillText('BEST: ' + selBest, GW/2, sy + LEVEL_KEYS.length * rowH + 5);
        }

        // Instructions
        if (Math.floor(fc / 20) % 2 === 0) {
            ctx.font = '7px "Press Start 2P"';
            ctx.fillStyle = '#543';
            ctx.fillText('â†‘â†“ SELECT  SPACE START', GW/2, GH - GROUND_H - 20);
        }

        ctx.restore();
    }

    // ============ GAME LOGIC ============
    function flap() {
        if (state === 'title') {
            initAudio();
            sfxSwoosh();
            currentLevel = LEVEL_KEYS[selectedIdx];
            diff = LEVELS[currentLevel];
            best = getBest();
            state = 'ready';
            readyTimer = 0;
            showScore = true;
            // Reset bird position
            bird.y = 180;
            bird.vy = 0;
            bird.rot = 0;
            return;
        }
        if (state === 'ready') {
            state = 'play';
            bird.vy = diff.flap;
            bird.wing = Math.PI;
            sfxFlap();
            addPipe();
            return;
        }
        if (state === 'play') {
            // Only flap if not already going up fast
            if (bird.vy > diff.flap * 0.5) {
                bird.vy = diff.flap;
            }
            bird.wing = Math.PI;
            sfxFlap();
            return;
        }
        if (state === 'dying') {
            return; // can't flap while dying
        }
        if (state === 'dead') {
            sfxSwoosh();
            resetGame();
            return;
        }
    }

    // Also allow continuous flapping by holding space
    let spaceHeld = false;
    let flapCooldown = 0;

    function resetGame() {
        bird = { x: 68, y: 180, vy: 0, rot: 0, wing: 0, frame: 0 };
        pipes = []; score = 0; fc = 0; groundX = 0;
        flashAlpha = 0; showScore = false;
        state = 'title';
    }

    function addPipe() {
        const min = 80, max = GROUND_Y - diff.gap - 80;
        const topH = Math.random() * (max - min) + min;
        const last = pipes[pipes.length - 1];
        const x = last ? last.x + diff.dist : GW + diff.firstPipe;
        pipes.push({ x, topH, scored: false });
    }

    function die() {
        if (state !== 'play') return;
        state = 'dying';
        sfxHit();
        flashAlpha = 1;
        bird.vy = -5;
        if (score > best) { best = score; setBest(best); }
    }

    // ============ UPDATE ============
    function update() {
        fc++;
        clouds.forEach(c => { c.x -= 0.2; if (c.x < -60) c.x = GW + 40; });

        if (state === 'title') {
            bird.y = 180 + Math.sin(fc * 0.07) * 10;
            bird.wing += 0.18;
            groundX += 1.5;
            return;
        }

        if (state === 'ready') {
            bird.y = 180 + Math.sin(fc * 0.07) * 10;
            bird.wing += 0.18;
            groundX += diff.speed;
            readyTimer++;
            return;
        }

        if (state === 'play' || state === 'dying') {
            bird.vy += diff.gravity;
            bird.vy = Math.min(bird.vy, diff.maxFall);
            bird.vy = Math.max(bird.vy, -diff.maxFall); // also cap upward speed!
            bird.y += bird.vy;
            // Clamp bird to screen â€” don't let it fly off top
            if (bird.y < BIRD_H / 2) {
                bird.y = BIRD_H / 2;
                bird.vy = 0;
            }
            if (bird.vy < -2) bird.rot = Math.max(-0.45, bird.rot - 0.1);
            else bird.rot = Math.min(Math.PI / 2, bird.rot + 0.035);
            bird.wing += bird.vy < 0 ? 0.45 : 0.1;
        }

        if (state === 'play') {
            groundX += diff.speed;
            pipes.forEach(p => p.x -= diff.speed);
            if (pipes.length && pipes[0].x < -PIPE_W - 10) pipes.shift();
            const last = pipes[pipes.length - 1];
            if (!last || last.x < GW - diff.dist) addPipe();

            // Score
            pipes.forEach(p => {
                if (!p.scored && p.x + PIPE_W < bird.x) {
                    p.scored = true; score++; sfxScore();
                }
            });

            // Collision
            if (bird.y + BIRD_H/2 > GROUND_Y - 2) die();
            pipes.forEach(p => {
                if (bird.x + BIRD_W/2 - diff.hbx > p.x && bird.x - BIRD_W/2 + diff.hbx < p.x + PIPE_W) {
                    if (bird.y - BIRD_H/2 + diff.hby < p.topH || bird.y + BIRD_H/2 - diff.hby > p.topH + diff.gap) die();
                }
            });
        }

        if (state === 'dying') {
            if (bird.y + BIRD_H/2 >= GROUND_Y - 2) {
                bird.y = GROUND_Y - BIRD_H/2 - 2;
                bird.vy = 0;
                if (state === 'dying') {
                    state = 'dead';
                    sfxDie();
                }
            }
        }

        if (flashAlpha > 0) flashAlpha -= 0.08;
    }

    // ============ DRAW ============
    function draw() {
        drawBg();
        pipes.forEach(p => drawPipe(p.x, p.topH));
        drawGround();
        drawBird();
        drawScore();

        if (state === 'title') drawTitle();
        if (state === 'ready') drawGetReady();
        if (state === 'dead') drawGameOver();

        // White flash
        if (flashAlpha > 0) {
            ctx.fillStyle = `rgba(255,255,255,${Math.max(0, flashAlpha)})`;
            ctx.fillRect(0, 0, GW, GH);
        }
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }

    // ============ INPUT ============
    document.addEventListener('keydown', e => {
        e.preventDefault(); // prevent page scroll on ALL keys
        if (state === 'title') {
            if (e.code === 'ArrowUp') { selectedIdx = Math.max(0, selectedIdx - 1); sfxScore(); return; }
            if (e.code === 'ArrowDown') { selectedIdx = Math.min(LEVEL_KEYS.length - 1, selectedIdx + 1); sfxScore(); return; }
            if (e.code === 'Space' || e.code === 'Enter') { flap(); return; }
            return;
        }
        if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
            if (!e.repeat) flap(); // only flap on fresh press, not key repeat
        }
    });
    document.addEventListener('keyup', e => {
        e.preventDefault();
    });
    function handleCanvasTap(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = GW / rect.width;
        const scaleY = GH / rect.height;
        const cx = (clientX - rect.left) * scaleX;
        const cy = (clientY - rect.top) * scaleY;

        if (state === 'title') {
            // Check if tapping a level button
            const sy = 195, rowH = 30;
            for (let i = 0; i < LEVEL_KEYS.length; i++) {
                const y = sy + i * rowH;
                if (cx > GW/2 - 65 && cx < GW/2 + 65 && cy > y - 10 && cy < y + 14) {
                    if (i === selectedIdx) {
                        flap(); // double-tap selected = start
                    } else {
                        selectedIdx = i;
                        initAudio();
                        sfxScore();
                    }
                    return;
                }
            }
            // Tap elsewhere = start with selected
            flap();
            return;
        }
        flap();
    }
    canvas.addEventListener('click', e => { e.preventDefault(); handleCanvasTap(e.clientX, e.clientY); });
    canvas.addEventListener('touchstart', e => { e.preventDefault(); handleCanvasTap(e.touches[0].clientX, e.touches[0].clientY); });

    document.getElementById('sound-toggle').addEventListener('click', e => {
        e.stopPropagation();
        initAudio();
        soundEnabled = !soundEnabled;
        const btn = document.getElementById('sound-toggle');
        btn.textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
        btn.classList.toggle('muted', !soundEnabled);
        if (masterGain) masterGain.gain.value = soundEnabled ? 0.3 : 0;
    });

    initWorld();
    canvas.setAttribute('tabindex', '0');
    canvas.focus();
    loop();
    </script>
</body>
</html>
