<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Flappy Bird</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #4ec0ca;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 480px;
            aspect-ratio: 3/4;
            max-height: 100vh;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #sound-toggle {
            position: absolute;
            top: 8px; right: 8px;
            z-index: 25;
            background: rgba(255,255,255,0.6);
            border: 2px solid #543;
            color: #543;
            font-size: 14px;
            width: 30px; height: 30px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
        }
        #sound-toggle.muted { opacity: 0.35; }
        @media (max-width: 480px) { #game-container { max-width: 100vw; } }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game"></canvas>
        <button id="sound-toggle" title="Toggle Sound">ðŸ”Š</button>
    </div>

    <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const GW = 288, GH = 512;
    canvas.width = GW;
    canvas.height = GH;

    // ============ AUDIO ============
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null, masterGain = null, soundEnabled = true;
    function initAudio() {
        if (audioCtx) return;
        audioCtx = new AudioCtx();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.3;
        masterGain.connect(audioCtx.destination);
    }
    function playTone(freq, dur, type, vol) {
        if (!audioCtx || !soundEnabled) return;
        const t = audioCtx.currentTime;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type || 'sine'; o.frequency.value = freq;
        g.gain.setValueAtTime(vol || 0.12, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + dur);
        o.connect(g); g.connect(masterGain);
        o.start(t); o.stop(t + dur);
    }
    function sfxFlap() { playTone(600, 0.07, 'triangle', 0.15); }
    function sfxScore() { playTone(800, 0.06, 'sine', 0.12); setTimeout(() => playTone(1200, 0.1, 'sine', 0.1), 60); }
    function sfxHit() { playTone(180, 0.12, 'square', 0.14); }
    function sfxDie() { playTone(250, 0.12, 'sawtooth', 0.08); setTimeout(() => playTone(150, 0.2, 'sawtooth', 0.06), 100); }
    function sfxSwoosh() { playTone(400, 0.1, 'sine', 0.06); playTone(500, 0.08, 'triangle', 0.04); }

    // ============ CONSTANTS ============
    const GRAVITY = 0.25;
    const FLAP = -4.5;
    const PIPE_SPD = 1.6;
    const PIPE_GAP = 145;
    const PIPE_W = 52;
    const PIPE_DIST = 190;
    const GROUND_H = 112;
    const GROUND_Y = GH - GROUND_H;
    const BIRD_W = 34, BIRD_H = 24;

    // ============ STATE ============
    let best = parseInt(localStorage.getItem('fb_best') || '0');
    let bird = { x: 68, y: 200, vy: 0, rot: 0, wing: 0, frame: 0 };
    let pipes = [], score = 0, state = 'title', fc = 0, groundX = 0;
    let flashAlpha = 0, dieY = 0, showScore = false;
    let readyTimer = 0;
    let clouds = [], buildings = [];

    function initWorld() {
        clouds = [];
        for (let i = 0; i < 5; i++) clouds.push({ x: Math.random() * GW * 1.2, y: 30 + Math.random() * 100, s: 0.6 + Math.random() * 0.6 });
        buildings = [];
        let bx = 0;
        while (bx < GW + 60) { const w = 14 + Math.random() * 22; buildings.push({ x: bx, w, h: 20 + Math.random() * 55 }); bx += w + Math.random() * 4; }
    }

    // ============ DRAW HELPERS ============
    function drawRoundRect(x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }

    // ============ BACKGROUND ============
    function drawBg() {
        // Sky gradient
        const g = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
        g.addColorStop(0, '#4ec0ca');
        g.addColorStop(0.6, '#62d0d0');
        g.addColorStop(1, '#b0e8b0');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, GW, GROUND_Y);

        // Clouds
        clouds.forEach(c => {
            drawCloud(c.x, c.y, c.s);
        });

        // City far (light)
        ctx.fillStyle = 'rgba(180,210,160,0.7)';
        buildings.forEach(b => {
            const ox = ((b.x - groundX * 0.1) % (GW + 60) + GW + 60) % (GW + 60) - 30;
            ctx.fillRect(ox, GROUND_Y - b.h * 0.5, b.w, b.h * 0.5);
        });
        // City near
        ctx.fillStyle = 'rgba(140,190,130,0.8)';
        buildings.forEach(b => {
            const ox = ((b.x + 40 - groundX * 0.2) % (GW + 60) + GW + 60) % (GW + 60) - 30;
            ctx.fillRect(ox, GROUND_Y - b.h * 0.35, b.w * 0.9, b.h * 0.35);
        });
    }

    function drawCloud(x, y, scale) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI * 2);
        ctx.arc(20, -5, 16, 0, Math.PI * 2);
        ctx.arc(-18, 2, 14, 0, Math.PI * 2);
        ctx.arc(10, 5, 14, 0, Math.PI * 2);
        ctx.arc(-8, -8, 13, 0, Math.PI * 2);
        ctx.arc(30, 3, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // ============ PIPES ============
    function drawPipe(px, topH) {
        const capH = 26, capOv = 3;
        const bodyX = px, bodyW = PIPE_W;
        const capX = px - capOv, capW = PIPE_W + capOv * 2;
        const botY = topH + PIPE_GAP;
        const botH = GROUND_Y - botY;

        // --- TOP PIPE ---
        // Body
        drawPipeBody(bodyX, 0, bodyW, topH - capH);
        // Cap
        drawPipeCap(capX, topH - capH, capW, capH);

        // --- BOTTOM PIPE ---
        // Cap
        drawPipeCap(capX, botY, capW, capH);
        // Body
        drawPipeBody(bodyX, botY + capH, bodyW, botH - capH);
    }

    function drawPipeBody(x, y, w, h) {
        if (h <= 0) return;
        // Main green
        ctx.fillStyle = '#73bf2e';
        ctx.fillRect(x, y, w, h);
        // Left highlight
        ctx.fillStyle = '#8fd644';
        ctx.fillRect(x + 2, y, 6, h);
        // Second highlight
        ctx.fillStyle = '#a0e855';
        ctx.fillRect(x + 8, y, 3, h);
        // Right shadow
        ctx.fillStyle = '#568f1e';
        ctx.fillRect(x + w - 7, y, 7, h);
        // Dark edge
        ctx.fillStyle = '#3a6a10';
        ctx.fillRect(x + w - 2, y, 2, h);
        // Left dark edge
        ctx.fillStyle = '#4a7a18';
        ctx.fillRect(x, y, 2, h);
        // Outline
        ctx.strokeStyle = '#2a5a10';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(x, y, w, h);
    }

    function drawPipeCap(x, y, w, h) {
        // Main
        ctx.fillStyle = '#73bf2e';
        drawRoundRect(x, y, w, h, 3);
        ctx.fill();
        // Left highlight
        ctx.fillStyle = '#8fd644';
        ctx.fillRect(x + 3, y + 2, 6, h - 4);
        ctx.fillStyle = '#a0e855';
        ctx.fillRect(x + 9, y + 2, 3, h - 4);
        // Right shadow
        ctx.fillStyle = '#568f1e';
        ctx.fillRect(x + w - 8, y + 2, 6, h - 4);
        ctx.fillStyle = '#3a6a10';
        ctx.fillRect(x + w - 3, y + 2, 2, h - 4);
        // Outline
        ctx.strokeStyle = '#2a5a10';
        ctx.lineWidth = 1.5;
        drawRoundRect(x, y, w, h, 3);
        ctx.stroke();
        // Top/bottom shine line
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillRect(x + 4, y + 2, w - 8, 2);
    }

    // ============ GROUND ============
    function drawGround() {
        // Grass
        ctx.fillStyle = '#6abf2e';
        ctx.fillRect(0, GROUND_Y, GW, 6);
        // Ground body
        ctx.fillStyle = '#ded895';
        ctx.fillRect(0, GROUND_Y + 6, GW, GROUND_H - 6);
        // Ground stripes
        ctx.fillStyle = '#c8b864';
        const sw = 24;
        for (let gx = -(groundX % (sw * 2)); gx < GW + sw; gx += sw * 2) {
            ctx.fillRect(gx, GROUND_Y + 12, sw, 4);
        }
        for (let gx = -(groundX % (sw * 2)) + sw; gx < GW + sw; gx += sw * 2) {
            ctx.fillRect(gx, GROUND_Y + 22, sw, 4);
        }
        // Top dark line
        ctx.fillStyle = '#543';
        ctx.fillRect(0, GROUND_Y, GW, 2);
    }

    // ============ BIRD ============
    function drawBird() {
        const { x, y, rot } = bird;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rot);

        const bw = BIRD_W, bh = BIRD_H;

        // Tail feathers
        ctx.fillStyle = '#ddd';
        ctx.beginPath();
        ctx.moveTo(-bw/2 + 3, -3);
        ctx.lineTo(-bw/2 - 8, -7);
        ctx.lineTo(-bw/2 - 7, 0);
        ctx.lineTo(-bw/2 - 8, 7);
        ctx.lineTo(-bw/2 + 3, 4);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Body shadow
        ctx.fillStyle = '#c87000';
        ctx.beginPath();
        ctx.ellipse(0, 2, bw/2, bh/2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Main body â€” orange like original
        const bg = ctx.createRadialGradient(-4, -3, 1, 0, 0, bw/2);
        bg.addColorStop(0, '#ffc840');
        bg.addColorStop(0.4, '#f0a020');
        bg.addColorStop(0.8, '#e08010');
        bg.addColorStop(1, '#d07008');
        ctx.fillStyle = bg;
        ctx.beginPath();
        ctx.ellipse(0, 0, bw/2, bh/2, 0, 0, Math.PI * 2);
        ctx.fill();
        // Outline
        ctx.strokeStyle = '#805000';
        ctx.lineWidth = 1.8;
        ctx.stroke();

        // Belly patch (lighter)
        ctx.fillStyle = '#fce0a0';
        ctx.beginPath();
        ctx.ellipse(4, 4, bw/2 - 8, bh/2 - 5, 0.1, 0, Math.PI * 2);
        ctx.fill();

        // Wing
        const wy = Math.sin(bird.wing) * 5;
        ctx.fillStyle = '#eee';
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.ellipse(-3, wy + 1, 12, 7, -0.1, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Wing inner detail
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.ellipse(-2, wy, 7, 4, -0.1, 0, Math.PI * 2);
        ctx.fill();

        // Eye white â€” big round like original
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(10, -4, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Pupil â€” big and centered-right
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(13, -4, 4, 0, Math.PI * 2);
        ctx.fill();

        // Eye highlight
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(14.5, -6, 1.8, 0, Math.PI * 2);
        ctx.fill();

        // Beak â€” bright orange/red, two parts
        // Top beak
        ctx.fillStyle = '#f04030';
        ctx.beginPath();
        ctx.moveTo(14, -2);
        ctx.lineTo(26, 1);
        ctx.lineTo(14, 3);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#901808';
        ctx.lineWidth = 0.8;
        ctx.stroke();
        // Bottom beak (slightly lower, darker)
        ctx.fillStyle = '#d03020';
        ctx.beginPath();
        ctx.moveTo(14, 3);
        ctx.lineTo(24, 3);
        ctx.lineTo(14, 7);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#901808';
        ctx.stroke();

        ctx.restore();
    }

    // ============ UI ============
    function drawScore() {
        if (!showScore) return;
        const s = String(score);
        ctx.save();
        ctx.font = '28px "Press Start 2P"';
        ctx.textAlign = 'center';
        // Shadow
        ctx.fillStyle = '#543';
        ctx.fillText(s, GW/2 + 2, 52);
        // White
        ctx.fillStyle = '#fff';
        ctx.fillText(s, GW/2, 50);
        ctx.restore();
    }

    function drawGetReady() {
        ctx.save();
        ctx.textAlign = 'center';

        // "GET READY" text
        ctx.font = '18px "Press Start 2P"';
        ctx.fillStyle = '#543';
        ctx.fillText('GET READY', GW/2 + 2, 152);
        ctx.fillStyle = '#fff';
        ctx.fillText('GET READY', GW/2, 150);

        // Tap hand icon
        const hx = GW/2, hy = 280;
        // Hand circle
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.beginPath();
        ctx.arc(hx, hy, 22, 0, Math.PI * 2);
        ctx.fill();
        // Hand
        ctx.fillStyle = '#ded895';
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 1.5;
        // Palm
        ctx.beginPath();
        ctx.arc(hx, hy, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Finger
        ctx.fillStyle = '#ded895';
        ctx.beginPath();
        ctx.moveTo(hx - 4, hy - 10);
        ctx.lineTo(hx + 4, hy - 10);
        ctx.lineTo(hx + 3, hy - 26);
        ctx.lineTo(hx - 3, hy - 26);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        // Finger tip round
        ctx.beginPath();
        ctx.arc(hx, hy - 26, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Tap lines
        const tapAnim = Math.sin(fc * 0.1) * 3;
        ctx.strokeStyle = 'rgba(84,51,0,0.4)';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 3; i++) {
            const a = -Math.PI/2 + (i - 1) * 0.5;
            const r1 = 28 + tapAnim;
            const r2 = 36 + tapAnim;
            ctx.beginPath();
            ctx.moveTo(hx + Math.cos(a) * r1, hy + Math.sin(a) * r1 - 10);
            ctx.lineTo(hx + Math.cos(a) * r2, hy + Math.sin(a) * r2 - 10);
            ctx.stroke();
        }

        ctx.restore();
    }

    function drawGameOver() {
        ctx.save();
        ctx.textAlign = 'center';

        // "GAME OVER" text
        ctx.font = '18px "Press Start 2P"';
        ctx.fillStyle = '#543';
        ctx.fillText('GAME OVER', GW/2 + 2, 102);
        ctx.fillStyle = '#fff';
        ctx.fillText('GAME OVER', GW/2, 100);

        // Score panel
        const px = GW/2 - 80, py = 120, pw = 160, ph = 90;
        // Panel shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        drawRoundRect(px + 3, py + 3, pw, ph, 6);
        ctx.fill();
        // Panel bg
        ctx.fillStyle = '#ded895';
        drawRoundRect(px, py, pw, ph, 6);
        ctx.fill();
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 2.5;
        drawRoundRect(px, py, pw, ph, 6);
        ctx.stroke();
        // Inner border
        ctx.strokeStyle = 'rgba(84,51,0,0.2)';
        ctx.lineWidth = 1;
        drawRoundRect(px + 5, py + 5, pw - 10, ph - 10, 4);
        ctx.stroke();

        // Medal
        const mx = px + 24, my = py + ph/2;
        if (score >= 40) drawMedal(mx, my, '#ffd700', '#fff5a0'); // gold
        else if (score >= 20) drawMedal(mx, my, '#c0c0c0', '#e8e8e8'); // silver
        else if (score >= 10) drawMedal(mx, my, '#cd7f32', '#e0a050'); // bronze

        // Score
        ctx.textAlign = 'right';
        ctx.font = '12px "Press Start 2P"';
        ctx.fillStyle = '#543';
        ctx.fillText('SCORE', px + pw - 14, py + 28);
        ctx.fillStyle = '#fff';
        ctx.font = '14px "Press Start 2P"';
        ctx.fillText(String(score), px + pw - 14, py + 46);

        // Best
        ctx.font = '12px "Press Start 2P"';
        ctx.fillStyle = '#543';
        ctx.fillText('BEST', px + pw - 14, py + 62);
        ctx.fillStyle = '#fff';
        ctx.font = '14px "Press Start 2P"';
        ctx.fillText(String(best), px + pw - 14, py + 80);

        // NEW badge
        if (score > 0 && score >= best) {
            ctx.save();
            ctx.translate(px + pw - 50, py + 52);
            ctx.rotate(-0.1);
            ctx.fillStyle = '#f85030';
            drawRoundRect(-14, -7, 28, 13, 2);
            ctx.fill();
            ctx.font = '6px "Press Start 2P"';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText('NEW', 0, 3);
            ctx.restore();
        }

        // Play button
        const bx = GW/2 - 40, by = py + ph + 16, bw = 80, bh = 32;
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        drawRoundRect(bx + 2, by + 2, bw, bh, 4);
        ctx.fill();
        ctx.fillStyle = '#e08020';
        drawRoundRect(bx, by, bw, bh, 4);
        ctx.fill();
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 2;
        drawRoundRect(bx, by, bw, bh, 4);
        ctx.stroke();
        ctx.textAlign = 'center';
        ctx.font = '11px "Press Start 2P"';
        ctx.fillStyle = '#fff';
        ctx.fillText('PLAY', GW/2, by + 21);

        ctx.restore();
    }

    function drawMedal(cx, cy, c1, c2) {
        // Medal circle
        const g = ctx.createRadialGradient(cx - 3, cy - 3, 1, cx, cy, 16);
        g.addColorStop(0, c2);
        g.addColorStop(1, c1);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(cx, cy, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        // Star
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        drawStar(cx, cy, 5, 10, 5);
        ctx.fill();
    }

    function drawStar(cx, cy, spikes, outerR, innerR) {
        let rot = Math.PI / 2 * 3, step = Math.PI / spikes;
        ctx.beginPath();
        ctx.moveTo(cx, cy - outerR);
        for (let i = 0; i < spikes; i++) {
            ctx.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
            rot += step;
            ctx.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
            rot += step;
        }
        ctx.closePath();
    }

    function drawStyledText(text, x, y, size, fillColor, strokeColor, strokeW, tilt) {
        ctx.save();
        ctx.translate(x, y);
        if (tilt) ctx.rotate(tilt);
        ctx.font = `900 ${size}px "Press Start 2P"`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // Thick outline
        ctx.lineWidth = strokeW || 4;
        ctx.strokeStyle = strokeColor || '#543';
        ctx.lineJoin = 'round';
        ctx.miterLimit = 2;
        ctx.strokeText(text, 0, 0);
        // Fill
        ctx.fillStyle = fillColor || '#fff';
        ctx.fillText(text, 0, 0);
        ctx.restore();
    }

    function drawTitle() {
        ctx.save();

        // Title "Flappy Bird" â€” styled like original with thick outlines
        // "Flappy" â€” white with green tint, thick dark outline
        drawStyledText('Flappy', GW/2, 110, 28, '#fff', '#543', 5, -0.05);
        // "Bird" â€” slightly offset, same style
        drawStyledText('Bird', GW/2 + 10, 145, 28, '#fff', '#543', 5, 0.03);

        // Subtitle blink
        if (Math.floor(fc / 20) % 2 === 0) {
            ctx.font = '9px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#543';
            ctx.fillText('TAP TO START', GW/2, 310);
        }

        ctx.restore();
    }

    // ============ GAME LOGIC ============
    function flap() {
        if (state === 'title') {
            initAudio();
            sfxSwoosh();
            state = 'ready';
            readyTimer = 0;
            showScore = true;
            return;
        }
        if (state === 'ready') {
            state = 'play';
            bird.vy = FLAP * 0.8;
            bird.wing = Math.PI;
            sfxFlap();
            addPipe();
            return;
        }
        if (state === 'play') {
            bird.vy = FLAP;
            bird.wing = Math.PI;
            sfxFlap();
            return;
        }
        if (state === 'dead') {
            // Check if tap is on play button
            sfxSwoosh();
            resetGame();
            return;
        }
    }

    function resetGame() {
        bird = { x: 68, y: 200, vy: 0, rot: 0, wing: 0, frame: 0 };
        pipes = []; score = 0; fc = 0; groundX = 0;
        flashAlpha = 0; showScore = true;
        state = 'ready';
        readyTimer = 0;
    }

    function addPipe() {
        const min = 60, max = GROUND_Y - PIPE_GAP - 60;
        const topH = Math.random() * (max - min) + min;
        const last = pipes[pipes.length - 1];
        const x = last ? last.x + PIPE_DIST : GW + 140;
        pipes.push({ x, topH, scored: false });
    }

    function die() {
        if (state !== 'play') return;
        state = 'dying';
        sfxHit();
        flashAlpha = 1;
        bird.vy = -5;
        if (score > best) { best = score; localStorage.setItem('fb_best', best); }
    }

    // ============ UPDATE ============
    function update() {
        fc++;
        clouds.forEach(c => { c.x -= 0.2; if (c.x < -60) c.x = GW + 40; });

        if (state === 'title') {
            bird.y = 200 + Math.sin(fc * 0.07) * 10;
            bird.wing += 0.18;
            groundX += PIPE_SPD;
            return;
        }

        if (state === 'ready') {
            bird.y = 200 + Math.sin(fc * 0.07) * 10;
            bird.wing += 0.18;
            groundX += PIPE_SPD;
            readyTimer++;
            return;
        }

        if (state === 'play' || state === 'dying') {
            bird.vy += GRAVITY;
            bird.vy = Math.min(bird.vy, 6);
            bird.y += bird.vy;
            if (bird.vy < -2) bird.rot = Math.max(-0.45, bird.rot - 0.1);
            else bird.rot = Math.min(Math.PI / 2, bird.rot + 0.035);
            bird.wing += bird.vy < 0 ? 0.45 : 0.1;
        }

        if (state === 'play') {
            groundX += PIPE_SPD;
            pipes.forEach(p => p.x -= PIPE_SPD);
            if (pipes.length && pipes[0].x < -PIPE_W - 10) pipes.shift();
            const last = pipes[pipes.length - 1];
            if (!last || last.x < GW - PIPE_DIST) addPipe();

            // Score
            pipes.forEach(p => {
                if (!p.scored && p.x + PIPE_W < bird.x) {
                    p.scored = true; score++; sfxScore();
                }
            });

            // Collision
            if (bird.y + BIRD_H/2 > GROUND_Y - 2 || bird.y - BIRD_H/2 < 0) die();
            pipes.forEach(p => {
                if (bird.x + BIRD_W/2 - 8 > p.x && bird.x - BIRD_W/2 + 8 < p.x + PIPE_W) {
                    if (bird.y - BIRD_H/2 + 6 < p.topH || bird.y + BIRD_H/2 - 6 > p.topH + PIPE_GAP) die();
                }
            });
        }

        if (state === 'dying') {
            if (bird.y + BIRD_H/2 >= GROUND_Y - 2) {
                bird.y = GROUND_Y - BIRD_H/2 - 2;
                bird.vy = 0;
                if (state === 'dying') {
                    state = 'dead';
                    sfxDie();
                }
            }
        }

        if (flashAlpha > 0) flashAlpha -= 0.08;
    }

    // ============ DRAW ============
    function draw() {
        drawBg();
        pipes.forEach(p => drawPipe(p.x, p.topH));
        drawGround();
        drawBird();
        drawScore();

        if (state === 'title') drawTitle();
        if (state === 'ready') drawGetReady();
        if (state === 'dead') drawGameOver();

        // White flash
        if (flashAlpha > 0) {
            ctx.fillStyle = `rgba(255,255,255,${Math.max(0, flashAlpha)})`;
            ctx.fillRect(0, 0, GW, GH);
        }
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }

    // ============ INPUT ============
    document.addEventListener('keydown', e => {
        if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); flap(); }
    });
    canvas.addEventListener('click', e => { e.preventDefault(); flap(); });
    canvas.addEventListener('touchstart', e => { e.preventDefault(); flap(); });

    document.getElementById('sound-toggle').addEventListener('click', e => {
        e.stopPropagation();
        initAudio();
        soundEnabled = !soundEnabled;
        const btn = document.getElementById('sound-toggle');
        btn.textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
        btn.classList.toggle('muted', !soundEnabled);
        if (masterGain) masterGain.gain.value = soundEnabled ? 0.3 : 0;
    });

    initWorld();
    loop();
    </script>
</body>
</html>
