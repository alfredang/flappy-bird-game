<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Flappy Bird</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #4ec0ca;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 480px;
            aspect-ratio: 9/16;
            max-height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 0;
            image-rendering: pixelated;
        }

        #ui-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #score-display {
            position: absolute;
            top: 8%;
            width: 100%;
            text-align: center;
            font-size: clamp(32px, 9vw, 64px);
            color: #fff;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 0 3px 0 #543;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #score-display.visible { opacity: 1; }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            z-index: 20;
        }

        #start-screen {
            background: transparent;
        }

        #start-screen h1 {
            font-size: clamp(22px, 6vw, 40px);
            color: #fff;
            text-shadow: 2px 2px 0 #543, -1px -1px 0 #543, 3px 3px 0 rgba(0,0,0,0.2);
            margin-bottom: 10px;
            text-align: center;
        }

        #start-screen .subtitle {
            color: #fff;
            font-size: clamp(8px, 2vw, 12px);
            margin-bottom: 40px;
            text-shadow: 1px 1px 0 #543;
        }

        .tap-hint {
            color: #543;
            font-size: clamp(10px, 2.5vw, 14px);
            animation: blink 1.2s steps(2) infinite;
            margin-top: 15px;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        #game-over-screen {
            background: rgba(0,0,0,0.3);
            display: none;
        }

        .game-over-panel {
            background: #ded895;
            border: 3px solid #543;
            border-radius: 8px;
            padding: 20px 30px;
            text-align: center;
            box-shadow: 0 4px 0 #543;
        }

        .game-over-panel h2 {
            font-size: clamp(18px, 5vw, 30px);
            color: #543;
            margin-bottom: 15px;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            font-size: clamp(10px, 2.5vw, 14px);
            color: #543;
        }

        .score-row .val {
            color: #f00;
            font-size: clamp(14px, 3.5vw, 22px);
        }

        .medal {
            width: 44px; height: 44px;
            border-radius: 50%;
            display: inline-block;
            margin: 10px 0;
        }

        .btn-retro {
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(10px, 2.5vw, 14px);
            padding: 12px 30px;
            border: 3px solid #543;
            background: #e08020;
            color: #fff;
            cursor: pointer;
            text-shadow: 1px 1px 0 #543;
            box-shadow: 0 4px 0 #543;
            margin-top: 15px;
            transition: transform 0.1s;
        }

        .btn-retro:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #543;
        }

        #sound-toggle {
            position: absolute;
            top: 10px; right: 10px;
            z-index: 25;
            background: rgba(255,255,255,0.7);
            border: 2px solid #543;
            color: #543;
            font-size: 16px;
            width: 34px; height: 34px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
        }
        #sound-toggle.muted { opacity: 0.4; }

        @media (max-width: 480px) {
            #game-container { max-width: 100vw; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game"></canvas>

        <div id="ui-overlay">
            <div id="score-display">0</div>
            <button id="sound-toggle" title="Toggle Sound">ðŸ”Š</button>
        </div>

        <div id="start-screen">
            <h1>FLAPPY BIRD</h1>
            <div class="subtitle">TAP TO START</div>
            <div class="tap-hint">SPACE / CLICK / TAP</div>
        </div>

        <div id="game-over-screen">
            <div class="game-over-panel">
                <h2>GAME OVER</h2>
                <div class="score-row"><span>SCORE</span><span class="val" id="final-score">0</span></div>
                <div class="score-row"><span>BEST</span><span class="val" id="best-score">0</span></div>
                <button class="btn-retro" id="restart-btn">PLAY</button>
            </div>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const GW = 480, GH = 854;
    canvas.width = GW;
    canvas.height = GH;

    // ==================== SOUND SYSTEM ====================
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null, masterGain = null, soundEnabled = true;

    function initAudio() {
        if (audioCtx) return;
        audioCtx = new AudioCtx();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.25;
        masterGain.connect(audioCtx.destination);
    }

    function playTone(freq, dur, type, vol) {
        if (!audioCtx || !soundEnabled) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type || 'sine';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(vol || 0.12, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
        osc.connect(gain);
        gain.connect(masterGain);
        osc.start(t);
        osc.stop(t + dur);
    }

    function sfxFlap() { playTone(600, 0.08, 'sine', 0.12); playTone(800, 0.06, 'triangle', 0.06); }
    function sfxScore() { [800, 1000, 1200].forEach((f, i) => setTimeout(() => playTone(f, 0.1, 'sine', 0.1), i * 40)); }
    function sfxHit() { playTone(200, 0.15, 'square', 0.12); playTone(100, 0.2, 'sawtooth', 0.08); }
    function sfxDie() { [300, 250, 180, 120].forEach((f, i) => setTimeout(() => playTone(f, 0.18, 'sawtooth', 0.07), i * 80)); }
    function sfxStart() { [400, 500, 600, 800].forEach((f, i) => setTimeout(() => playTone(f, 0.08, 'sine', 0.07), i * 50)); }

    // ==================== COLORS ====================
    const SKY_TOP = '#4ec0ca';
    const SKY_BOT = '#e0f0e0';
    const PIPE_GREEN = '#73bf2e';
    const PIPE_GREEN_DARK = '#568f1e';
    const PIPE_GREEN_LIGHT = '#8fd644';
    const PIPE_CAP_H = 30;
    const GROUND_COLOR = '#ded895';
    const GROUND_DARK = '#d3c46b';
    const GROUND_H = 112;

    // ==================== STATE ====================
    let bestScore = parseInt(localStorage.getItem('flappyBirdBest') || '0');
    const bird = { x: GW * 0.25, y: GH / 2 - 50, vy: 0, rotation: 0, wingPhase: 0, frame: 0 };
    let pipes = [], clouds = [], cityBuildings = [];
    let score = 0, gameState = 'menu', frameCount = 0, groundX = 0;
    let flashTimer = 0, fallDone = false;

    const GRAVITY = 0.42;
    const FLAP_FORCE = -7.5;
    const PIPE_SPEED = 2.5;
    const PIPE_GAP = 160;
    const PIPE_WIDTH = 62;
    const PIPE_SPACING = 210;
    const BIRD_W = 38, BIRD_H = 28;

    // Init clouds
    function initClouds() {
        clouds = [];
        for (let i = 0; i < 6; i++) {
            clouds.push({
                x: Math.random() * GW * 1.5,
                y: Math.random() * (GH * 0.35) + 30,
                w: Math.random() * 80 + 60,
                h: Math.random() * 25 + 15,
                speed: Math.random() * 0.3 + 0.15,
            });
        }
    }

    // Init city silhouette
    function initCity() {
        cityBuildings = [];
        let cx = 0;
        while (cx < GW + 100) {
            const w = Math.random() * 30 + 20;
            const h = Math.random() * 60 + 30;
            cityBuildings.push({ x: cx, w, h });
            cx += w + Math.random() * 5;
        }
    }

    // ==================== DRAWING ====================
    function drawSky() {
        const grad = ctx.createLinearGradient(0, 0, 0, GH - GROUND_H);
        grad.addColorStop(0, SKY_TOP);
        grad.addColorStop(1, '#aed9a0');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, GW, GH - GROUND_H);
    }

    function drawClouds() {
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        clouds.forEach(c => {
            // Draw puffy cloud with overlapping circles
            const rx = c.w / 2, ry = c.h / 2;
            ctx.beginPath();
            ctx.ellipse(c.x, c.y, rx, ry, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(c.x - rx * 0.5, c.y + ry * 0.2, rx * 0.6, ry * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(c.x + rx * 0.5, c.y + ry * 0.15, rx * 0.7, ry * 0.75, 0, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function drawCity() {
        const groundY = GH - GROUND_H;
        ctx.fillStyle = '#a8c090';
        cityBuildings.forEach(b => {
            ctx.fillRect(b.x - groundX * 0.15 % (GW + 200) - 100, groundY - b.h, b.w, b.h);
        });
        // Second layer darker
        ctx.fillStyle = '#8eb070';
        cityBuildings.forEach(b => {
            const ox = (b.x + 50) % (GW + 100);
            ctx.fillRect(ox - groundX * 0.25 % (GW + 200) - 100, groundY - b.h * 0.7, b.w * 0.8, b.h * 0.7);
        });
    }

    function drawPipe(x, topH) {
        const groundY = GH - GROUND_H;
        const bottomY = topH + PIPE_GAP;
        const bottomH = groundY - bottomY;

        // Top pipe body
        ctx.fillStyle = PIPE_GREEN;
        ctx.fillRect(x, 0, PIPE_WIDTH, topH - PIPE_CAP_H);
        // Top pipe left highlight
        ctx.fillStyle = PIPE_GREEN_LIGHT;
        ctx.fillRect(x + 3, 0, 8, topH - PIPE_CAP_H);
        // Top pipe right shadow
        ctx.fillStyle = PIPE_GREEN_DARK;
        ctx.fillRect(x + PIPE_WIDTH - 8, 0, 8, topH - PIPE_CAP_H);
        // Top pipe outline
        ctx.strokeStyle = '#2a5a10';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, 0, PIPE_WIDTH, topH - PIPE_CAP_H);

        // Top pipe cap
        const capX = x - 4, capW = PIPE_WIDTH + 8;
        ctx.fillStyle = PIPE_GREEN;
        ctx.fillRect(capX, topH - PIPE_CAP_H, capW, PIPE_CAP_H);
        ctx.fillStyle = PIPE_GREEN_LIGHT;
        ctx.fillRect(capX + 3, topH - PIPE_CAP_H, 8, PIPE_CAP_H);
        ctx.fillStyle = PIPE_GREEN_DARK;
        ctx.fillRect(capX + capW - 8, topH - PIPE_CAP_H, 8, PIPE_CAP_H);
        ctx.strokeStyle = '#2a5a10';
        ctx.strokeRect(capX, topH - PIPE_CAP_H, capW, PIPE_CAP_H);

        // Bottom pipe cap
        ctx.fillStyle = PIPE_GREEN;
        ctx.fillRect(capX, bottomY, capW, PIPE_CAP_H);
        ctx.fillStyle = PIPE_GREEN_LIGHT;
        ctx.fillRect(capX + 3, bottomY, 8, PIPE_CAP_H);
        ctx.fillStyle = PIPE_GREEN_DARK;
        ctx.fillRect(capX + capW - 8, bottomY, 8, PIPE_CAP_H);
        ctx.strokeStyle = '#2a5a10';
        ctx.strokeRect(capX, bottomY, capW, PIPE_CAP_H);

        // Bottom pipe body
        ctx.fillStyle = PIPE_GREEN;
        ctx.fillRect(x, bottomY + PIPE_CAP_H, PIPE_WIDTH, bottomH - PIPE_CAP_H);
        ctx.fillStyle = PIPE_GREEN_LIGHT;
        ctx.fillRect(x + 3, bottomY + PIPE_CAP_H, 8, bottomH - PIPE_CAP_H);
        ctx.fillStyle = PIPE_GREEN_DARK;
        ctx.fillRect(x + PIPE_WIDTH - 8, bottomY + PIPE_CAP_H, 8, bottomH - PIPE_CAP_H);
        ctx.strokeStyle = '#2a5a10';
        ctx.strokeRect(x, bottomY + PIPE_CAP_H, PIPE_WIDTH, bottomH - PIPE_CAP_H);
    }

    function drawGround() {
        const gy = GH - GROUND_H;
        // Main ground
        ctx.fillStyle = GROUND_COLOR;
        ctx.fillRect(0, gy, GW, GROUND_H);
        // Dark stripe at top
        ctx.fillStyle = GROUND_DARK;
        ctx.fillRect(0, gy, GW, 15);
        // Green grass line
        ctx.fillStyle = '#6abf2e';
        ctx.fillRect(0, gy, GW, 4);
        // Dashed ground texture
        ctx.fillStyle = '#c4b460';
        const dashW = 30;
        for (let dx = -groundX % (dashW * 2); dx < GW; dx += dashW * 2) {
            ctx.fillRect(dx, gy + 20, dashW, 3);
            ctx.fillRect(dx + dashW, gy + 35, dashW, 3);
        }
    }

    function drawBird() {
        const { x, y, rotation } = bird;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);

        // Body (orange/yellow)
        ctx.fillStyle = '#f8c53a';
        ctx.beginPath();
        ctx.ellipse(0, 0, BIRD_W / 2, BIRD_H / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Belly highlight
        ctx.fillStyle = '#fce38a';
        ctx.beginPath();
        ctx.ellipse(2, 4, BIRD_W / 2 - 6, BIRD_H / 2 - 6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Wing
        const wingY = Math.sin(bird.wingPhase) * 4;
        ctx.fillStyle = '#e8a020';
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.ellipse(-6, wingY, 12, 7, -0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Eye white
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.ellipse(10, -5, 7, 7, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#543';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Pupil
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(13, -5, 3.5, 4, 0, 0, Math.PI * 2);
        ctx.fill();

        // Eye highlight
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(14, -7, 1.5, 0, Math.PI * 2);
        ctx.fill();

        // Beak (orange-red)
        ctx.fillStyle = '#e84030';
        ctx.beginPath();
        ctx.moveTo(15, -1);
        ctx.lineTo(26, 2);
        ctx.lineTo(15, 5);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#a02818';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Beak line
        ctx.strokeStyle = '#a02818';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(15, 2);
        ctx.lineTo(26, 2);
        ctx.stroke();

        // Red cheek
        ctx.fillStyle = 'rgba(232,64,48,0.25)';
        ctx.beginPath();
        ctx.arc(8, 5, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    // ==================== GAME LOGIC ====================
    function flap() {
        if (gameState === 'menu') {
            initAudio();
            sfxStart();
            startGame();
            return;
        }
        if (gameState === 'dead') return;
        if (gameState === 'dying') return;
        if (gameState === 'playing') {
            bird.vy = FLAP_FORCE;
            bird.wingPhase = Math.PI;
            sfxFlap();
        }
    }

    function startGame() {
        bird.y = GH / 2 - 50;
        bird.vy = 0;
        bird.rotation = 0;
        bird.wingPhase = 0;
        pipes = [];
        score = 0;
        frameCount = 0;
        groundX = 0;
        flashTimer = 0;
        fallDone = false;
        gameState = 'playing';

        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('game-over-screen').style.display = 'none';
        document.getElementById('score-display').classList.add('visible');
        document.getElementById('score-display').textContent = '0';

        addPipe();
    }

    function addPipe() {
        const minTop = 100;
        const maxTop = GH - GROUND_H - PIPE_GAP - 100;
        const topH = Math.random() * (maxTop - minTop) + minTop;
        const lastPipe = pipes[pipes.length - 1];
        const x = lastPipe ? lastPipe.x + PIPE_SPACING : GW + 80;
        pipes.push({ x, topH, scored: false });
    }

    function die() {
        if (gameState !== 'playing') return;
        gameState = 'dying';
        sfxHit();
        flashTimer = 6;
        bird.vy = -5;
    }

    function showGameOver() {
        gameState = 'dead';
        const isNew = score > bestScore;
        if (isNew) {
            bestScore = score;
            localStorage.setItem('flappyBirdBest', bestScore);
        }
        document.getElementById('final-score').textContent = score;
        document.getElementById('best-score').textContent = bestScore;
        document.getElementById('game-over-screen').style.display = 'flex';
        document.getElementById('score-display').classList.remove('visible');
        sfxDie();
    }

    function update() {
        frameCount++;

        // Clouds always move
        clouds.forEach(c => {
            c.x -= c.speed;
            if (c.x < -c.w * 2) c.x = GW + c.w;
        });

        if (gameState === 'menu') {
            // Idle bird bobbing
            bird.y = GH / 2 - 50 + Math.sin(frameCount * 0.06) * 12;
            bird.wingPhase += 0.15;
            groundX += PIPE_SPEED;
            return;
        }

        if (gameState === 'playing' || gameState === 'dying') {
            bird.vy += GRAVITY;
            bird.y += bird.vy;

            // Rotation
            if (bird.vy < -2) bird.rotation = -0.4;
            else if (bird.vy < 0) bird.rotation = -0.2;
            else bird.rotation = Math.min(Math.PI / 2, bird.rotation + 0.04);

            // Wing
            bird.wingPhase += bird.vy < 0 ? 0.4 : 0.12;
        }

        if (gameState === 'playing') {
            groundX += PIPE_SPEED;

            // Pipes
            pipes.forEach(p => p.x -= PIPE_SPEED);
            if (pipes.length > 0 && pipes[0].x < -PIPE_WIDTH - 20) pipes.shift();
            const lastPipe = pipes[pipes.length - 1];
            if (!lastPipe || lastPipe.x < GW - PIPE_SPACING) addPipe();

            // Scoring
            pipes.forEach(p => {
                if (!p.scored && p.x + PIPE_WIDTH < bird.x) {
                    p.scored = true;
                    score++;
                    sfxScore();
                    document.getElementById('score-display').textContent = score;
                }
            });

            // Collision â€” ground/ceiling
            const groundY = GH - GROUND_H;
            if (bird.y + BIRD_H / 2 > groundY || bird.y - BIRD_H / 2 < 0) {
                die();
            }

            // Collision â€” pipes
            const bx = bird.x, by = bird.y;
            const hr = BIRD_W / 2 - 4, vr = BIRD_H / 2 - 3;
            pipes.forEach(p => {
                if (bx + hr > p.x && bx - hr < p.x + PIPE_WIDTH) {
                    if (by - vr < p.topH || by + vr > p.topH + PIPE_GAP) {
                        die();
                    }
                }
            });
        }

        if (gameState === 'dying') {
            // Bird falls and hits ground
            const groundY = GH - GROUND_H;
            if (bird.y + BIRD_H / 2 >= groundY) {
                bird.y = groundY - BIRD_H / 2;
                bird.vy = 0;
                if (!fallDone) {
                    fallDone = true;
                    setTimeout(showGameOver, 400);
                }
            }
        }

        if (flashTimer > 0) flashTimer--;
    }

    function draw() {
        ctx.clearRect(0, 0, GW, GH);
        drawSky();
        drawClouds();
        drawCity();

        // Pipes
        if (gameState !== 'menu') {
            pipes.forEach(p => drawPipe(p.x, p.topH));
        }

        drawGround();

        // Bird
        drawBird();

        // Flash on hit
        if (flashTimer > 0) {
            ctx.fillStyle = `rgba(255,255,255,${flashTimer / 6 * 0.5})`;
            ctx.fillRect(0, 0, GW, GH);
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // ==================== INPUT ====================
    document.addEventListener('keydown', e => {
        if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); flap(); }
    });
    canvas.addEventListener('click', flap);
    canvas.addEventListener('touchstart', e => { e.preventDefault(); flap(); });

    document.getElementById('restart-btn').addEventListener('click', e => {
        e.stopPropagation();
        initAudio();
        sfxStart();
        startGame();
    });

    document.getElementById('sound-toggle').addEventListener('click', e => {
        e.stopPropagation();
        initAudio();
        soundEnabled = !soundEnabled;
        const btn = document.getElementById('sound-toggle');
        btn.textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
        btn.classList.toggle('muted', !soundEnabled);
        if (masterGain) masterGain.gain.value = soundEnabled ? 0.25 : 0;
    });

    // ==================== INIT ====================
    initClouds();
    initCity();
    loop();
    </script>
</body>
</html>
